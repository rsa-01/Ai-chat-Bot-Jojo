import{counterToBytes as U,createCryptoContext as j,createGuardrails as z,dynamicTruncate as T,truncateDigits as P,validateCounter as H,validateSecret as k,validateToken as E,validateCounterTolerance as M,normalizeSecret as b,normalizeCounterTolerance as L,requireSecret as C,requireCryptoPlugin as x}from"@otplib/core";import{generateSecret as S,requireCryptoPlugin as y,requireBase32Plugin as q,requireSecret as g,requireLabel as I,requireIssuer as D,requireBase32String as A,createGuardrails as N}from"@otplib/core";import{generateHOTP as w}from"@otplib/uri";var m=class{options;guardrails;constructor(t={}){this.options=t,this.guardrails=N(t.guardrails)}generateSecret(){let{crypto:t,base32:e}=this.options;return y(t),q(e),S({crypto:t,base32:e})}async generate(t,e){let r={...this.options,...e},{secret:i,crypto:n,base32:o,algorithm:a="sha1",digits:s=6}=r;g(i),y(n);let c=e?.guardrails??this.guardrails;return O({secret:i,counter:t,algorithm:a,digits:s,crypto:n,base32:o,guardrails:c,hooks:r.hooks})}async verify(t,e){let r={...this.options,...e},{secret:i,crypto:n,base32:o,algorithm:a="sha1",digits:s=6,counterTolerance:c=0}=r;g(i),y(n);let p=e?.guardrails??this.guardrails;return h({secret:i,token:t.token,counter:t.counter,algorithm:a,digits:s,counterTolerance:c,crypto:n,base32:o,guardrails:p,hooks:r.hooks})}toURI(t=0){let{issuer:e,label:r,secret:i,algorithm:n="sha1",digits:o=6}=this.options;return g(i),I(r),D(e),A(i),w({issuer:e,label:r,secret:i,algorithm:n,digits:o,counter:t})}};import{wrapResult as ee,wrapResultAsync as te}from"@otplib/core";function v(u){let{secret:t,counter:e,algorithm:r="sha1",digits:i=6,crypto:n,base32:o,guardrails:a,hooks:s}=u;C(t),x(n);let c=b(t,o);k(c,a),H(e,a);let p=j(n),l=U(e);return{ctx:p,algorithm:r,digits:i,secretBytes:c,counterBytes:l,hooks:s}}async function O(u){let{ctx:t,algorithm:e,digits:r,secretBytes:i,counterBytes:n,hooks:o}=v(u),a=await t.hmac(e,i,n),s=o?.truncateDigest?o.truncateDigest(a):T(a);return o?.encodeToken?o.encodeToken(s,r):P(s,r)}function F(u){let{ctx:t,algorithm:e,digits:r,secretBytes:i,counterBytes:n,hooks:o}=v(u),a=t.hmacSync(e,i,n),s=o?.truncateDigest?o.truncateDigest(a):T(a);return o?.encodeToken?o.encodeToken(s,r):P(s,r)}function G(u){let{secret:t,counter:e,token:r,algorithm:i="sha1",digits:n=6,crypto:o,base32:a,counterTolerance:s=0,guardrails:c=z(),hooks:p}=u;C(t),x(o);let l=b(t,a);k(l,c),H(e,c),p?.validateToken?p.validateToken(r,n):E(r,n),M(s,c);let V=typeof e=="bigint"?Number(e):e,[f,d]=L(s),R=f+d+1;return{token:r,counterNum:V,past:f,future:d,totalChecks:R,crypto:o,getGenerateOptions:B=>({secret:l,counter:B,algorithm:i,digits:n,crypto:o,guardrails:c,hooks:p})}}async function h(u){let{token:t,counterNum:e,past:r,totalChecks:i,crypto:n,getGenerateOptions:o}=G(u),a=Math.max(0,r-e);for(let s=a;s<i;s++){let c=s-r,p=e+c,l=await O(o(p));if(n.constantTimeEqual(l,t))return{valid:!0,delta:c|0}}return{valid:!1}}function Y(u){let{token:t,counterNum:e,past:r,totalChecks:i,crypto:n,getGenerateOptions:o}=G(u),a=Math.max(0,r-e);for(let s=a;s<i;s++){let c=s-r,p=e+c,l=F(o(p));if(n.constantTimeEqual(l,t))return{valid:!0,delta:c|0}}return{valid:!1}}export{m as HOTP,O as generate,F as generateSync,h as verify,Y as verifySync,ee as wrapResult,te as wrapResultAsync};
//# sourceMappingURL=index.js.map