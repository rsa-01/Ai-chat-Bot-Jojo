"use strict";var d=Object.defineProperty;var V=Object.getOwnPropertyDescriptor;var R=Object.getOwnPropertyNames;var B=Object.prototype.hasOwnProperty;var S=(c,e)=>{for(var t in e)d(c,t,{get:e[t],enumerable:!0})},q=(c,e,t,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of R(e))!B.call(c,n)&&n!==t&&d(c,n,{get:()=>e[n],enumerable:!(o=V(e,n))||o.enumerable});return c};var I=c=>q(d({},"__esModule",{value:!0}),c);var A={};S(A,{HOTP:()=>m,generate:()=>O,generateSync:()=>b,verify:()=>h,verifySync:()=>D,wrapResult:()=>f.wrapResult,wrapResultAsync:()=>f.wrapResultAsync});module.exports=I(A);var r=require("@otplib/core");var u=require("@otplib/core"),H=require("@otplib/uri");var m=class{options;guardrails;constructor(e={}){this.options=e,this.guardrails=(0,u.createGuardrails)(e.guardrails)}generateSecret(){let{crypto:e,base32:t}=this.options;return(0,u.requireCryptoPlugin)(e),(0,u.requireBase32Plugin)(t),(0,u.generateSecret)({crypto:e,base32:t})}async generate(e,t){let o={...this.options,...t},{secret:n,crypto:i,base32:s,algorithm:p="sha1",digits:a=6}=o;(0,u.requireSecret)(n),(0,u.requireCryptoPlugin)(i);let l=t?.guardrails??this.guardrails;return O({secret:n,counter:e,algorithm:p,digits:a,crypto:i,base32:s,guardrails:l,hooks:o.hooks})}async verify(e,t){let o={...this.options,...t},{secret:n,crypto:i,base32:s,algorithm:p="sha1",digits:a=6,counterTolerance:l=0}=o;(0,u.requireSecret)(n),(0,u.requireCryptoPlugin)(i);let y=t?.guardrails??this.guardrails;return h({secret:n,token:e.token,counter:e.counter,algorithm:p,digits:a,counterTolerance:l,crypto:i,base32:s,guardrails:y,hooks:o.hooks})}toURI(e=0){let{issuer:t,label:o,secret:n,algorithm:i="sha1",digits:s=6}=this.options;return(0,u.requireSecret)(n),(0,u.requireLabel)(o),(0,u.requireIssuer)(t),(0,u.requireBase32String)(n),(0,H.generateHOTP)({issuer:t,label:o,secret:n,algorithm:i,digits:s,counter:e})}};var f=require("@otplib/core");function k(c){let{secret:e,counter:t,algorithm:o="sha1",digits:n=6,crypto:i,base32:s,guardrails:p,hooks:a}=c;(0,r.requireSecret)(e),(0,r.requireCryptoPlugin)(i);let l=(0,r.normalizeSecret)(e,s);(0,r.validateSecret)(l,p),(0,r.validateCounter)(t,p);let y=(0,r.createCryptoContext)(i),g=(0,r.counterToBytes)(t);return{ctx:y,algorithm:o,digits:n,secretBytes:l,counterBytes:g,hooks:a}}async function O(c){let{ctx:e,algorithm:t,digits:o,secretBytes:n,counterBytes:i,hooks:s}=k(c),p=await e.hmac(t,n,i),a=s?.truncateDigest?s.truncateDigest(p):(0,r.dynamicTruncate)(p);return s?.encodeToken?s.encodeToken(a,o):(0,r.truncateDigits)(a,o)}function b(c){let{ctx:e,algorithm:t,digits:o,secretBytes:n,counterBytes:i,hooks:s}=k(c),p=e.hmacSync(t,n,i),a=s?.truncateDigest?s.truncateDigest(p):(0,r.dynamicTruncate)(p);return s?.encodeToken?s.encodeToken(a,o):(0,r.truncateDigits)(a,o)}function C(c){let{secret:e,counter:t,token:o,algorithm:n="sha1",digits:i=6,crypto:s,base32:p,counterTolerance:a=0,guardrails:l=(0,r.createGuardrails)(),hooks:y}=c;(0,r.requireSecret)(e),(0,r.requireCryptoPlugin)(s);let g=(0,r.normalizeSecret)(e,p);(0,r.validateSecret)(g,l),(0,r.validateCounter)(t,l),y?.validateToken?y.validateToken(o,i):(0,r.validateToken)(o,i),(0,r.validateCounterTolerance)(a,l);let x=typeof t=="bigint"?Number(t):t,[T,P]=(0,r.normalizeCounterTolerance)(a),v=T+P+1;return{token:o,counterNum:x,past:T,future:P,totalChecks:v,crypto:s,getGenerateOptions:G=>({secret:g,counter:G,algorithm:n,digits:i,crypto:s,guardrails:l,hooks:y})}}async function h(c){let{token:e,counterNum:t,past:o,totalChecks:n,crypto:i,getGenerateOptions:s}=C(c),p=Math.max(0,o-t);for(let a=p;a<n;a++){let l=a-o,y=t+l,g=await O(s(y));if(i.constantTimeEqual(g,e))return{valid:!0,delta:l|0}}return{valid:!1}}function D(c){let{token:e,counterNum:t,past:o,totalChecks:n,crypto:i,getGenerateOptions:s}=C(c),p=Math.max(0,o-t);for(let a=p;a<n;a++){let l=a-o,y=t+l,g=b(s(y));if(i.constantTimeEqual(g,e))return{valid:!0,delta:l|0}}return{valid:!1}}0&&(module.exports={HOTP,generate,generateSync,verify,verifySync,wrapResult,wrapResultAsync});
//# sourceMappingURL=index.cjs.map