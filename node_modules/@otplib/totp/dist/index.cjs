"use strict";var b=Object.defineProperty;var A=Object.getOwnPropertyDescriptor;var D=Object.getOwnPropertyNames;var E=Object.prototype.hasOwnProperty;var H=(r,e)=>{for(var n in e)b(r,n,{get:e[n],enumerable:!0})},B=(r,e,n,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of D(e))!E.call(r,o)&&o!==n&&b(r,o,{get:()=>e[o],enumerable:!(s=A(e,o))||s.enumerable});return r};var U=r=>B(b({},"__esModule",{value:!0}),r);var F={};H(F,{TOTP:()=>O,generate:()=>y,generateSync:()=>G,getRemainingTime:()=>j,getTimeStepUsed:()=>z,verify:()=>S,verifySync:()=>N,wrapResult:()=>P.wrapResult,wrapResultAsync:()=>P.wrapResultAsync});module.exports=U(F);var t=require("@otplib/core"),h=require("@otplib/hotp");var u=require("@otplib/core"),C=require("@otplib/uri");var O=class{options;guardrails;constructor(e={}){this.options=e,this.guardrails=(0,u.createGuardrails)(e.guardrails)}generateSecret(){let{crypto:e,base32:n}=this.options;return(0,u.requireCryptoPlugin)(e),(0,u.requireBase32Plugin)(n),(0,u.generateSecret)({crypto:e,base32:n})}async generate(e){let n={...this.options,...e},{secret:s,crypto:o,base32:a,algorithm:f="sha1",digits:c=6,period:l=30,epoch:p,t0:i=0}=n;(0,u.requireSecret)(s),(0,u.requireCryptoPlugin)(o);let T=e?.guardrails??this.guardrails;return y({secret:s,algorithm:f,digits:c,period:l,epoch:p??Math.floor(Date.now()/1e3),t0:i,crypto:o,base32:a,guardrails:T,hooks:n.hooks})}async verify(e,n){let s={...this.options,...n},{secret:o,crypto:a,base32:f,algorithm:c="sha1",digits:l=6,period:p=30,epoch:i,t0:T=0,epochTolerance:m=0,afterTimeStep:g}=s;(0,u.requireSecret)(o),(0,u.requireCryptoPlugin)(a);let d=n?.guardrails??this.guardrails;return S({secret:o,token:e,algorithm:c,digits:l,period:p,epoch:i??Math.floor(Date.now()/1e3),t0:T,epochTolerance:m,afterTimeStep:g,crypto:a,base32:f,guardrails:d,hooks:s.hooks})}toURI(e){let{issuer:n,label:s,secret:o,algorithm:a="sha1",digits:f=6,period:c=30}=this.options,l=e?.label??s,p=e?.issuer??n,i=e?.secret??o;return(0,u.requireSecret)(i),(0,u.requireLabel)(l),(0,u.requireIssuer)(p),(0,u.requireBase32String)(i),(0,C.generateTOTP)({issuer:p,label:l,secret:i,algorithm:a,digits:f,period:c})}};var P=require("@otplib/core");function v(r){let{secret:e,epoch:n=Math.floor(Date.now()/1e3),t0:s=0,period:o=30,algorithm:a="sha1",digits:f=6,crypto:c,base32:l,guardrails:p=(0,t.createGuardrails)(),hooks:i}=r;(0,t.requireSecret)(e),(0,t.requireCryptoPlugin)(c);let T=(0,t.normalizeSecret)(e,l);(0,t.validateSecret)(T,p),(0,t.validateTime)(n),(0,t.validatePeriod)(o,p);let m=Math.floor((n-s)/o);return{secret:T,counter:m,algorithm:a,digits:f,crypto:c,guardrails:p,hooks:i}}async function y(r){let e=v(r);return(0,h.generate)(e)}function G(r){let e=v(r);return(0,h.generateSync)(e)}function L(r,e){if(r!==void 0){if(r<0)throw new t.AfterTimeStepNegativeError;if(!Number.isSafeInteger(r))throw new t.AfterTimeStepNotIntegerError;if(r>e)throw new t.AfterTimeStepRangeExceededError}}function V(r,e){return e!==void 0&&r<=e}function k(r){let{secret:e,token:n,epoch:s=Math.floor(Date.now()/1e3),t0:o=0,period:a=30,algorithm:f="sha1",digits:c=6,crypto:l,base32:p,epochTolerance:i=0,afterTimeStep:T,guardrails:m=(0,t.createGuardrails)(),hooks:g}=r;(0,t.requireSecret)(e),(0,t.requireCryptoPlugin)(l);let d=(0,t.normalizeSecret)(e,p);(0,t.validateSecret)(d,m),(0,t.validateTime)(s),(0,t.validatePeriod)(a,m),g?.validateToken?g.validateToken(n,c):(0,t.validateToken)(n,c),(0,t.validateEpochTolerance)(i,a,m);let w=Math.floor((s-o)/a),[R,M]=(0,t.normalizeEpochTolerance)(i),I=Math.max(0,Math.floor((s-R-o)/a)),x=Math.floor((s+M-o)/a);return L(T,x),{token:n,crypto:l,minCounter:I,maxCounter:x,currentCounter:w,t0:o,period:a,afterTimeStep:T,getGenerateOptions:q=>({secret:d,epoch:q*a+o,t0:o,period:a,algorithm:f,digits:c,crypto:l,guardrails:m,hooks:g})}}async function S(r){let{token:e,crypto:n,minCounter:s,maxCounter:o,currentCounter:a,t0:f,period:c,afterTimeStep:l,getGenerateOptions:p}=k(r);for(let i=s;i<=o;i++){if(V(i,l))continue;let T=await y(p(i));if(n.constantTimeEqual(T,e))return{valid:!0,delta:i-a,epoch:i*c+f,timeStep:i}}return{valid:!1}}function N(r){let{token:e,crypto:n,minCounter:s,maxCounter:o,currentCounter:a,t0:f,period:c,afterTimeStep:l,getGenerateOptions:p}=k(r);for(let i=s;i<=o;i++){if(V(i,l))continue;let T=G(p(i));if(n.constantTimeEqual(T,e))return{valid:!0,delta:i-a,epoch:i*c+f,timeStep:i}}return{valid:!1}}function j(r=Math.floor(Date.now()/1e3),e=30,n=0,s=(0,t.createGuardrails)()){return(0,t.validateTime)(r),(0,t.validatePeriod)(e,s),(Math.floor((r-n)/e)+1)*e+n-r}function z(r=Math.floor(Date.now()/1e3),e=30,n=0,s=(0,t.createGuardrails)()){return(0,t.validateTime)(r),(0,t.validatePeriod)(e,s),Math.floor((r-n)/e)}0&&(module.exports={TOTP,generate,generateSync,getRemainingTime,getTimeStepUsed,verify,verifySync,wrapResult,wrapResultAsync});
//# sourceMappingURL=index.cjs.map