import{createGuardrails as g,normalizeSecret as C,normalizeEpochTolerance as z,validateEpochTolerance as F,validatePeriod as d,validateSecret as v,validateTime as O,validateToken as J,requireSecret as G,requireCryptoPlugin as V,AfterTimeStepNegativeError as K,AfterTimeStepNotIntegerError as Q,AfterTimeStepRangeExceededError as W}from"@otplib/core";import{generate as X,generateSync as Y}from"@otplib/hotp";import{generateSecret as E,requireCryptoPlugin as y,requireBase32Plugin as H,requireSecret as h,requireLabel as B,requireIssuer as U,requireBase32String as L,createGuardrails as N}from"@otplib/core";import{generateTOTP as j}from"@otplib/uri";var P=class{options;guardrails;constructor(e={}){this.options=e,this.guardrails=N(e.guardrails)}generateSecret(){let{crypto:e,base32:n}=this.options;return y(e),H(n),E({crypto:e,base32:n})}async generate(e){let n={...this.options,...e},{secret:o,crypto:i,base32:s,algorithm:l="sha1",digits:a=6,period:u=30,epoch:c,t0:t=0}=n;h(o),y(i);let p=e?.guardrails??this.guardrails;return b({secret:o,algorithm:l,digits:a,period:u,epoch:c??Math.floor(Date.now()/1e3),t0:t,crypto:i,base32:s,guardrails:p,hooks:n.hooks})}async verify(e,n){let o={...this.options,...n},{secret:i,crypto:s,base32:l,algorithm:a="sha1",digits:u=6,period:c=30,epoch:t,t0:p=0,epochTolerance:f=0,afterTimeStep:T}=o;h(i),y(s);let m=n?.guardrails??this.guardrails;return x({secret:i,token:e,algorithm:a,digits:u,period:c,epoch:t??Math.floor(Date.now()/1e3),t0:p,epochTolerance:f,afterTimeStep:T,crypto:s,base32:l,guardrails:m,hooks:o.hooks})}toURI(e){let{issuer:n,label:o,secret:i,algorithm:s="sha1",digits:l=6,period:a=30}=this.options,u=e?.label??o,c=e?.issuer??n,t=e?.secret??i;return h(t),B(u),U(c),L(t),j({issuer:c,label:u,secret:t,algorithm:s,digits:l,period:a})}};import{wrapResult as pe,wrapResultAsync as fe}from"@otplib/core";function k(r){let{secret:e,epoch:n=Math.floor(Date.now()/1e3),t0:o=0,period:i=30,algorithm:s="sha1",digits:l=6,crypto:a,base32:u,guardrails:c=g(),hooks:t}=r;G(e),V(a);let p=C(e,u);v(p,c),O(n),d(i,c);let f=Math.floor((n-o)/i);return{secret:p,counter:f,algorithm:s,digits:l,crypto:a,guardrails:c,hooks:t}}async function b(r){let e=k(r);return X(e)}function Z(r){let e=k(r);return Y(e)}function _(r,e){if(r!==void 0){if(r<0)throw new K;if(!Number.isSafeInteger(r))throw new Q;if(r>e)throw new W}}function w(r,e){return e!==void 0&&r<=e}function R(r){let{secret:e,token:n,epoch:o=Math.floor(Date.now()/1e3),t0:i=0,period:s=30,algorithm:l="sha1",digits:a=6,crypto:u,base32:c,epochTolerance:t=0,afterTimeStep:p,guardrails:f=g(),hooks:T}=r;G(e),V(u);let m=C(e,c);v(m,f),O(o),d(s,f),T?.validateToken?T.validateToken(n,a):J(n,a),F(t,s,f);let M=Math.floor((o-i)/s),[I,q]=z(t),A=Math.max(0,Math.floor((o-I-i)/s)),S=Math.floor((o+q-i)/s);return _(p,S),{token:n,crypto:u,minCounter:A,maxCounter:S,currentCounter:M,t0:i,period:s,afterTimeStep:p,getGenerateOptions:D=>({secret:m,epoch:D*s+i,t0:i,period:s,algorithm:l,digits:a,crypto:u,guardrails:f,hooks:T})}}async function x(r){let{token:e,crypto:n,minCounter:o,maxCounter:i,currentCounter:s,t0:l,period:a,afterTimeStep:u,getGenerateOptions:c}=R(r);for(let t=o;t<=i;t++){if(w(t,u))continue;let p=await b(c(t));if(n.constantTimeEqual(p,e))return{valid:!0,delta:t-s,epoch:t*a+l,timeStep:t}}return{valid:!1}}function ie(r){let{token:e,crypto:n,minCounter:o,maxCounter:i,currentCounter:s,t0:l,period:a,afterTimeStep:u,getGenerateOptions:c}=R(r);for(let t=o;t<=i;t++){if(w(t,u))continue;let p=Z(c(t));if(n.constantTimeEqual(p,e))return{valid:!0,delta:t-s,epoch:t*a+l,timeStep:t}}return{valid:!1}}function se(r=Math.floor(Date.now()/1e3),e=30,n=0,o=g()){return O(r),d(e,o),(Math.floor((r-n)/e)+1)*e+n-r}function ae(r=Math.floor(Date.now()/1e3),e=30,n=0,o=g()){return O(r),d(e,o),Math.floor((r-n)/e)}export{P as TOTP,b as generate,Z as generateSync,se as getRemainingTime,ae as getTimeStepUsed,x as verify,ie as verifySync,pe as wrapResult,fe as wrapResultAsync};
//# sourceMappingURL=index.js.map