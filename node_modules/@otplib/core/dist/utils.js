var o=class extends Error{constructor(r,t){super(r,t),this.name="OTPError"}},x=class extends o{constructor(r){super(r),this.name="SecretError"}},f=class extends x{constructor(r,t){super(`Secret must be at least ${r} bytes (${r*8} bits), got ${t} bytes`),this.name="SecretTooShortError"}},m=class extends x{constructor(r,t){super(`Secret must not exceed ${r} bytes, got ${t} bytes`),this.name="SecretTooLongError"}},E=class extends o{constructor(r){super(r),this.name="CounterError"}},T=class extends E{constructor(){super("Counter must be non-negative"),this.name="CounterNegativeError"}},d=class extends E{constructor(){super("Counter exceeds maximum safe integer value"),this.name="CounterOverflowError"}},g=class extends E{constructor(){super("Counter must be a finite integer"),this.name="CounterNotIntegerError"}},b=class extends o{constructor(r){super(r),this.name="TimeError"}},h=class extends b{constructor(){super("Time must be non-negative"),this.name="TimeNegativeError"}},O=class extends b{constructor(){super("Time must be a finite number"),this.name="TimeNotFiniteError"}},S=class extends o{constructor(r){super(r),this.name="PeriodError"}},_=class extends S{constructor(r){super(`Period must be at least ${r} second(s)`),this.name="PeriodTooSmallError"}},A=class extends S{constructor(r){super(`Period must not exceed ${r} seconds`),this.name="PeriodTooLargeError"}};var w=class extends o{constructor(r){super(r),this.name="TokenError"}},I=class extends w{constructor(r,t){super(`Token must be ${r} digits, got ${t}`),this.name="TokenLengthError"}},P=class extends w{constructor(){super("Token must contain only digits"),this.name="TokenFormatError"}};var c=class extends o{constructor(r){super(r),this.name="CounterToleranceError"}},R=class extends c{constructor(r,t){super(`Counter tolerance validation failed: total checks (${t}) exceeds MAX_WINDOW (${r})`),this.name="CounterToleranceTooLargeError"}},M=class extends c{constructor(){super("Counter tolerance cannot contain negative values"),this.name="CounterToleranceNegativeError"}},p=class extends o{constructor(r){super(r),this.name="EpochToleranceError"}},y=class extends p{constructor(){super("Epoch tolerance cannot contain negative values"),this.name="EpochToleranceNegativeError"}},C=class extends p{constructor(r,t){super(`Epoch tolerance must not exceed ${r} seconds, got ${t}. Large tolerances can cause performance issues.`),this.name="EpochToleranceTooLargeError"}},N=class extends o{constructor(r){super(r),this.name="PluginError"}},B=class extends N{constructor(){super("Crypto plugin is required."),this.name="CryptoPluginMissingError"}},D=class extends N{constructor(){super("Base32 plugin is required."),this.name="Base32PluginMissingError"}},i=class extends o{constructor(r){super(r),this.name="ConfigurationError"}},v=class extends i{constructor(){super("Secret is required. Use generateSecret() to create one, or provide via { secret: 'YOUR_BASE32_SECRET' }"),this.name="SecretMissingError"}},X=class extends i{constructor(){super("Label is required for URI generation. Example: { label: 'user@example.com' }"),this.name="LabelMissingError"}},U=class extends i{constructor(){super("Issuer is required for URI generation. Example: { issuer: 'MyApp' }"),this.name="IssuerMissingError"}},Y=class extends i{constructor(){super("Class API requires secret to be a Base32 string, not Uint8Array. Use generateSecret() or provide a Base32-encoded string."),this.name="SecretTypeError"}};var F=new TextEncoder,z=new TextDecoder,V=16,j=64,H=20,J=1,K=3600,Q=30,Z=Number.MAX_SAFE_INTEGER,ee=99,G=Symbol("otplib.guardrails.override");function l(e,r,t){if(typeof r!="number"||!Number.isSafeInteger(r))throw new i(`Guardrail '${e}' must be a safe integer`);if(r<t)throw new i(`Guardrail '${e}' must be >= ${t}`)}var u=Object.freeze({MIN_SECRET_BYTES:V,MAX_SECRET_BYTES:j,MIN_PERIOD:J,MAX_PERIOD:K,MAX_COUNTER:Z,MAX_WINDOW:ee,[G]:!1});function ae(e){if(!e)return u;e.MIN_SECRET_BYTES!==void 0&&l("MIN_SECRET_BYTES",e.MIN_SECRET_BYTES,1),e.MAX_SECRET_BYTES!==void 0&&l("MAX_SECRET_BYTES",e.MAX_SECRET_BYTES,1),e.MIN_PERIOD!==void 0&&l("MIN_PERIOD",e.MIN_PERIOD,1),e.MAX_PERIOD!==void 0&&l("MAX_PERIOD",e.MAX_PERIOD,1),e.MAX_COUNTER!==void 0&&l("MAX_COUNTER",e.MAX_COUNTER,0),e.MAX_WINDOW!==void 0&&l("MAX_WINDOW",e.MAX_WINDOW,1);let r={...u,...e};if(r.MIN_SECRET_BYTES>r.MAX_SECRET_BYTES)throw new i("Guardrail 'MIN_SECRET_BYTES' must be <= 'MAX_SECRET_BYTES'");if(r.MIN_PERIOD>r.MAX_PERIOD)throw new i("Guardrail 'MIN_PERIOD' must be <= 'MAX_PERIOD'");return Object.freeze({...r,[G]:!0})}function ue(e){return e[G]??!1}function ce(e,r=u){if(e.length<r.MIN_SECRET_BYTES)throw new f(r.MIN_SECRET_BYTES,e.length);if(e.length>r.MAX_SECRET_BYTES)throw new m(r.MAX_SECRET_BYTES,e.length)}function pe(e,r=u){if(typeof e=="number"){if(!Number.isFinite(e)||!Number.isInteger(e))throw new g;if(!Number.isSafeInteger(e))throw new d}let t=typeof e=="bigint"?e:BigInt(e);if(t<0n)throw new T;if(t>BigInt(r.MAX_COUNTER))throw new d}function le(e){if(!Number.isFinite(e))throw new O;if(e<0)throw new h}function Ee(e,r=u){if(!Number.isInteger(e)||e<r.MIN_PERIOD)throw new _(r.MIN_PERIOD);if(e>r.MAX_PERIOD)throw new A(r.MAX_PERIOD)}function de(e,r){if(e.length!==r)throw new I(r,e.length);if(!/^\d+$/.test(e))throw new P}function xe(e,r=u){let[t,n]=te(e);if(!Number.isSafeInteger(t)||!Number.isSafeInteger(n))throw new c("Counter tolerance values must be safe integers");if(t<0||n<0)throw new M;let s=t+n+1;if(s>r.MAX_WINDOW)throw new R(r.MAX_WINDOW,s)}function fe(e,r=Q,t=u){let[n,s]=Array.isArray(e)?e:[e,e];if(!Number.isSafeInteger(n)||!Number.isSafeInteger(s))throw new p("Epoch tolerance values must be safe integers");if(n<0||s<0)throw new y;let a=(t.MAX_WINDOW-1)*r,$=n+s;if($>a)throw new C(a,$)}function me(e){let r=typeof e=="bigint"?e:BigInt(e),t=new ArrayBuffer(8);return new DataView(t).setBigUint64(0,r,!1),new Uint8Array(t)}function Te(e){let r=e[e.length-1]&15;return(e[r]&127)<<24|e[r+1]<<16|e[r+2]<<8|e[r+3]}function ge(e,r){let t=10**r;return(e%t).toString().padStart(r,"0")}function re(e,r){return e.length===r.length}function be(e,r){let t=W(e),n=W(r);if(!re(t,n))return!1;let s=0;for(let a=0;a<t.length;a++)s|=t[a]^n[a];return s===0}function he(e){switch(e){case"sha1":return 20;case"sha256":return 32;case"sha512":return 64}}function W(e){return typeof e=="string"?F.encode(e):e}function Oe(e){return z.decode(e)}function Se(e,r){return typeof e=="string"?(L(r),r.decode(e)):e}function _e(e){let{crypto:r,base32:t,length:n=H}=e;ne(r),L(t);let s=r.randomBytes(n);return t.encode(s,{padding:!1})}function te(e=0){return Array.isArray(e)?e:[0,e]}function Ae(e=0){return Array.isArray(e)?e:[e,e]}function ne(e){if(!e)throw new B}function L(e){if(!e)throw new D}function we(e){if(!e)throw new v}function Ie(e){if(!e)throw new X}function Pe(e){if(!e)throw new U}function Re(e){if(typeof e!="string")throw new Y}function k(e){return{ok:!0,value:e}}function q(e){return{ok:!1,error:e}}function Me(e){return(...r)=>{try{return k(e(...r))}catch(t){return q(t)}}}function ye(e){return async(...r)=>{try{return k(await e(...r))}catch(t){return q(t)}}}export{Q as DEFAULT_PERIOD,Z as MAX_COUNTER,K as MAX_PERIOD,j as MAX_SECRET_BYTES,ee as MAX_WINDOW,J as MIN_PERIOD,V as MIN_SECRET_BYTES,H as RECOMMENDED_SECRET_BYTES,Oe as bytesToString,be as constantTimeEqual,me as counterToBytes,ae as createGuardrails,Te as dynamicTruncate,_e as generateSecret,he as getDigestSize,ue as hasGuardrailOverrides,te as normalizeCounterTolerance,Ae as normalizeEpochTolerance,Se as normalizeSecret,L as requireBase32Plugin,Re as requireBase32String,ne as requireCryptoPlugin,Pe as requireIssuer,Ie as requireLabel,we as requireSecret,W as stringToBytes,ge as truncateDigits,re as validateByteLengthEqual,pe as validateCounter,xe as validateCounterTolerance,fe as validateEpochTolerance,Ee as validatePeriod,ce as validateSecret,le as validateTime,de as validateToken,Me as wrapResult,ye as wrapResultAsync};
//# sourceMappingURL=utils.js.map