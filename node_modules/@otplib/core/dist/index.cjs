"use strict";var nr=Object.defineProperty;var Fr=Object.getOwnPropertyDescriptor;var Vr=Object.getOwnPropertyNames;var Jr=Object.prototype.hasOwnProperty;var Qr=(r,e)=>{for(var t in e)nr(r,t,{get:e[t],enumerable:!0})},Zr=(r,e,t,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Vr(e))!Jr.call(r,n)&&n!==t&&nr(r,n,{get:()=>e[n],enumerable:!(o=Fr(e,n))||o.enumerable});return r};var re=r=>Zr(nr({},"__esModule",{value:!0}),r);var ne={};Qr(ne,{AfterTimeStepError:()=>T,AfterTimeStepNegativeError:()=>J,AfterTimeStepNotIntegerError:()=>Q,AfterTimeStepRangeExceededError:()=>Z,AlgorithmError:()=>V,Base32Context:()=>z,Base32DecodeError:()=>l,Base32EncodeError:()=>p,Base32Error:()=>v,Base32PluginMissingError:()=>Y,ConfigurationError:()=>a,CounterError:()=>d,CounterNegativeError:()=>P,CounterNotIntegerError:()=>O,CounterOverflowError:()=>m,CounterToleranceError:()=>g,CounterToleranceNegativeError:()=>U,CounterToleranceTooLargeError:()=>D,CryptoContext:()=>K,CryptoError:()=>M,CryptoPluginMissingError:()=>G,DEFAULT_PERIOD:()=>cr,DigitsError:()=>F,EpochToleranceError:()=>E,EpochToleranceNegativeError:()=>X,EpochToleranceTooLargeError:()=>k,HMACError:()=>c,IssuerMissingError:()=>$,LabelMissingError:()=>W,MAX_COUNTER:()=>pr,MAX_PERIOD:()=>ur,MAX_SECRET_BYTES:()=>sr,MAX_WINDOW:()=>lr,MIN_PERIOD:()=>ar,MIN_SECRET_BYTES:()=>or,OTPError:()=>s,PeriodError:()=>S,PeriodTooLargeError:()=>w,PeriodTooSmallError:()=>B,PluginError:()=>q,RECOMMENDED_SECRET_BYTES:()=>ir,RandomBytesError:()=>N,SecretError:()=>y,SecretMissingError:()=>L,SecretTooLongError:()=>h,SecretTooShortError:()=>x,SecretTypeError:()=>j,TimeError:()=>b,TimeNegativeError:()=>A,TimeNotFiniteError:()=>C,TokenError:()=>_,TokenFormatError:()=>I,TokenLengthError:()=>R,bytesToString:()=>_r,constantTimeEqual:()=>er,counterToBytes:()=>Cr,createBase32Context:()=>Lr,createBase32Plugin:()=>Wr,createCryptoContext:()=>Yr,createCryptoPlugin:()=>$r,createGuardrails:()=>Tr,dynamicTruncate:()=>Sr,generateSecret:()=>Ir,getDigestSize:()=>wr,hasBase32:()=>Kr,hasCrypto:()=>Hr,hasGuardrailOverrides:()=>fr,hasPlugins:()=>jr,normalizeCounterTolerance:()=>dr,normalizeEpochTolerance:()=>Mr,normalizeSecret:()=>Rr,requireBase32Plugin:()=>tr,requireBase32String:()=>Ur,requireCryptoPlugin:()=>mr,requireIssuer:()=>Dr,requireLabel:()=>vr,requireSecret:()=>Nr,stringToBytes:()=>rr,truncateDigits:()=>Br,validateByteLengthEqual:()=>Er,validateCounter:()=>xr,validateCounterTolerance:()=>br,validateEpochTolerance:()=>Ar,validatePeriod:()=>Pr,validateSecret:()=>yr,validateTime:()=>hr,validateToken:()=>Or,wrapResult:()=>qr,wrapResultAsync:()=>Gr});module.exports=re(ne);var s=class extends Error{constructor(e,t){super(e,t),this.name="OTPError"}},y=class extends s{constructor(e){super(e),this.name="SecretError"}},x=class extends y{constructor(e,t){super(`Secret must be at least ${e} bytes (${e*8} bits), got ${t} bytes`),this.name="SecretTooShortError"}},h=class extends y{constructor(e,t){super(`Secret must not exceed ${e} bytes, got ${t} bytes`),this.name="SecretTooLongError"}},d=class extends s{constructor(e){super(e),this.name="CounterError"}},P=class extends d{constructor(){super("Counter must be non-negative"),this.name="CounterNegativeError"}},m=class extends d{constructor(){super("Counter exceeds maximum safe integer value"),this.name="CounterOverflowError"}},O=class extends d{constructor(){super("Counter must be a finite integer"),this.name="CounterNotIntegerError"}},b=class extends s{constructor(e){super(e),this.name="TimeError"}},A=class extends b{constructor(){super("Time must be non-negative"),this.name="TimeNegativeError"}},C=class extends b{constructor(){super("Time must be a finite number"),this.name="TimeNotFiniteError"}},S=class extends s{constructor(e){super(e),this.name="PeriodError"}},B=class extends S{constructor(e){super(`Period must be at least ${e} second(s)`),this.name="PeriodTooSmallError"}},w=class extends S{constructor(e){super(`Period must not exceed ${e} seconds`),this.name="PeriodTooLargeError"}},F=class extends s{constructor(e){super(e),this.name="DigitsError"}},V=class extends s{constructor(e){super(e),this.name="AlgorithmError"}},_=class extends s{constructor(e){super(e),this.name="TokenError"}},R=class extends _{constructor(e,t){super(`Token must be ${e} digits, got ${t}`),this.name="TokenLengthError"}},I=class extends _{constructor(){super("Token must contain only digits"),this.name="TokenFormatError"}},M=class extends s{constructor(e,t){super(e,t),this.name="CryptoError"}},c=class extends M{constructor(e,t){super(`HMAC computation failed: ${e}`,t),this.name="HMACError"}},N=class extends M{constructor(e,t){super(`Random byte generation failed: ${e}`,t),this.name="RandomBytesError"}},v=class extends s{constructor(e,t){super(e,t),this.name="Base32Error"}},p=class extends v{constructor(e,t){super(`Base32 encoding failed: ${e}`,t),this.name="Base32EncodeError"}},l=class extends v{constructor(e,t){super(`Base32 decoding failed: ${e}`,t),this.name="Base32DecodeError"}},g=class extends s{constructor(e){super(e),this.name="CounterToleranceError"}},D=class extends g{constructor(e,t){super(`Counter tolerance validation failed: total checks (${t}) exceeds MAX_WINDOW (${e})`),this.name="CounterToleranceTooLargeError"}},U=class extends g{constructor(){super("Counter tolerance cannot contain negative values"),this.name="CounterToleranceNegativeError"}},E=class extends s{constructor(e){super(e),this.name="EpochToleranceError"}},X=class extends E{constructor(){super("Epoch tolerance cannot contain negative values"),this.name="EpochToleranceNegativeError"}},k=class extends E{constructor(e,t){super(`Epoch tolerance must not exceed ${e} seconds, got ${t}. Large tolerances can cause performance issues.`),this.name="EpochToleranceTooLargeError"}},q=class extends s{constructor(e){super(e),this.name="PluginError"}},G=class extends q{constructor(){super("Crypto plugin is required."),this.name="CryptoPluginMissingError"}},Y=class extends q{constructor(){super("Base32 plugin is required."),this.name="Base32PluginMissingError"}},a=class extends s{constructor(e){super(e),this.name="ConfigurationError"}},L=class extends a{constructor(){super("Secret is required. Use generateSecret() to create one, or provide via { secret: 'YOUR_BASE32_SECRET' }"),this.name="SecretMissingError"}},W=class extends a{constructor(){super("Label is required for URI generation. Example: { label: 'user@example.com' }"),this.name="LabelMissingError"}},$=class extends a{constructor(){super("Issuer is required for URI generation. Example: { issuer: 'MyApp' }"),this.name="IssuerMissingError"}},j=class extends a{constructor(){super("Class API requires secret to be a Base32 string, not Uint8Array. Use generateSecret() or provide a Base32-encoded string."),this.name="SecretTypeError"}},T=class extends s{constructor(e){super(e),this.name="AfterTimeStepError"}},J=class extends T{constructor(){super("afterTimeStep must be >= 0"),this.name="AfterTimeStepNegativeError"}},Q=class extends T{constructor(){super("Invalid afterTimeStep: non-integer value"),this.name="AfterTimeStepNotIntegerError"}},Z=class extends T{constructor(){super("Invalid afterTimeStep: cannot be greater than current time step plus window"),this.name="AfterTimeStepRangeExceededError"}};var ee=new TextEncoder,te=new TextDecoder,or=16,sr=64,ir=20,ar=1,ur=3600,cr=30,pr=Number.MAX_SAFE_INTEGER,lr=99,gr=Symbol("otplib.guardrails.override");function H(r,e,t){if(typeof e!="number"||!Number.isSafeInteger(e))throw new a(`Guardrail '${r}' must be a safe integer`);if(e<t)throw new a(`Guardrail '${r}' must be >= ${t}`)}var f=Object.freeze({MIN_SECRET_BYTES:or,MAX_SECRET_BYTES:sr,MIN_PERIOD:ar,MAX_PERIOD:ur,MAX_COUNTER:pr,MAX_WINDOW:lr,[gr]:!1});function Tr(r){if(!r)return f;r.MIN_SECRET_BYTES!==void 0&&H("MIN_SECRET_BYTES",r.MIN_SECRET_BYTES,1),r.MAX_SECRET_BYTES!==void 0&&H("MAX_SECRET_BYTES",r.MAX_SECRET_BYTES,1),r.MIN_PERIOD!==void 0&&H("MIN_PERIOD",r.MIN_PERIOD,1),r.MAX_PERIOD!==void 0&&H("MAX_PERIOD",r.MAX_PERIOD,1),r.MAX_COUNTER!==void 0&&H("MAX_COUNTER",r.MAX_COUNTER,0),r.MAX_WINDOW!==void 0&&H("MAX_WINDOW",r.MAX_WINDOW,1);let e={...f,...r};if(e.MIN_SECRET_BYTES>e.MAX_SECRET_BYTES)throw new a("Guardrail 'MIN_SECRET_BYTES' must be <= 'MAX_SECRET_BYTES'");if(e.MIN_PERIOD>e.MAX_PERIOD)throw new a("Guardrail 'MIN_PERIOD' must be <= 'MAX_PERIOD'");return Object.freeze({...e,[gr]:!0})}function fr(r){return r[gr]??!1}function yr(r,e=f){if(r.length<e.MIN_SECRET_BYTES)throw new x(e.MIN_SECRET_BYTES,r.length);if(r.length>e.MAX_SECRET_BYTES)throw new h(e.MAX_SECRET_BYTES,r.length)}function xr(r,e=f){if(typeof r=="number"){if(!Number.isFinite(r)||!Number.isInteger(r))throw new O;if(!Number.isSafeInteger(r))throw new m}let t=typeof r=="bigint"?r:BigInt(r);if(t<0n)throw new P;if(t>BigInt(e.MAX_COUNTER))throw new m}function hr(r){if(!Number.isFinite(r))throw new C;if(r<0)throw new A}function Pr(r,e=f){if(!Number.isInteger(r)||r<e.MIN_PERIOD)throw new B(e.MIN_PERIOD);if(r>e.MAX_PERIOD)throw new w(e.MAX_PERIOD)}function Or(r,e){if(r.length!==e)throw new R(e,r.length);if(!/^\d+$/.test(r))throw new I}function br(r,e=f){let[t,o]=dr(r);if(!Number.isSafeInteger(t)||!Number.isSafeInteger(o))throw new g("Counter tolerance values must be safe integers");if(t<0||o<0)throw new U;let n=t+o+1;if(n>e.MAX_WINDOW)throw new D(e.MAX_WINDOW,n)}function Ar(r,e=cr,t=f){let[o,n]=Array.isArray(r)?r:[r,r];if(!Number.isSafeInteger(o)||!Number.isSafeInteger(n))throw new E("Epoch tolerance values must be safe integers");if(o<0||n<0)throw new X;let i=(t.MAX_WINDOW-1)*e,u=o+n;if(u>i)throw new k(i,u)}function Cr(r){let e=typeof r=="bigint"?r:BigInt(r),t=new ArrayBuffer(8);return new DataView(t).setBigUint64(0,e,!1),new Uint8Array(t)}function Sr(r){let e=r[r.length-1]&15;return(r[e]&127)<<24|r[e+1]<<16|r[e+2]<<8|r[e+3]}function Br(r,e){let t=10**e;return(r%t).toString().padStart(e,"0")}function Er(r,e){return r.length===e.length}function er(r,e){let t=rr(r),o=rr(e);if(!Er(t,o))return!1;let n=0;for(let i=0;i<t.length;i++)n|=t[i]^o[i];return n===0}function wr(r){switch(r){case"sha1":return 20;case"sha256":return 32;case"sha512":return 64}}function rr(r){return typeof r=="string"?ee.encode(r):r}function _r(r){return te.decode(r)}function Rr(r,e){return typeof r=="string"?(tr(e),e.decode(r)):r}function Ir(r){let{crypto:e,base32:t,length:o=ir}=r;mr(e),tr(t);let n=e.randomBytes(o);return t.encode(n,{padding:!1})}function dr(r=0){return Array.isArray(r)?r:[0,r]}function Mr(r=0){return Array.isArray(r)?r:[r,r]}function mr(r){if(!r)throw new G}function tr(r){if(!r)throw new Y}function Nr(r){if(!r)throw new L}function vr(r){if(!r)throw new W}function Dr(r){if(!r)throw new $}function Ur(r){if(typeof r!="string")throw new j}function Xr(r){return{ok:!0,value:r}}function kr(r){return{ok:!1,error:r}}function qr(r){return(...e)=>{try{return Xr(r(...e))}catch(t){return kr(t)}}}function Gr(r){return async(...e)=>{try{return Xr(await r(...e))}catch(t){return kr(t)}}}var K=class{constructor(e){this.crypto=e}get plugin(){return this.crypto}async hmac(e,t,o){try{let n=this.crypto.hmac(e,t,o);return n instanceof Promise?await n:n}catch(n){let i=n instanceof Error?n.message:String(n);throw new c(i,{cause:n})}}hmacSync(e,t,o){try{let n=this.crypto.hmac(e,t,o);if(n instanceof Promise)throw new c("Crypto plugin does not support synchronous HMAC operations");return n}catch(n){if(n instanceof c)throw n;let i=n instanceof Error?n.message:String(n);throw new c(i,{cause:n})}}randomBytes(e){try{return this.crypto.randomBytes(e)}catch(t){let o=t instanceof Error?t.message:String(t);throw new N(o,{cause:t})}}};function Yr(r){return new K(r)}var z=class{constructor(e){this.base32=e}get plugin(){return this.base32}encode(e,t){try{return this.base32.encode(e,t)}catch(o){let n=o instanceof Error?o.message:String(o);throw new p(n,{cause:o})}}decode(e){try{return this.base32.decode(e)}catch(t){let o=t instanceof Error?t.message:String(t);throw new l(o,{cause:t})}}};function Lr(r){return new z(r)}function Wr(r){let{name:e="custom",encode:t,decode:o}=r;return Object.freeze({name:e,encode:(n,i)=>{try{return t(n)}catch(u){let zr=u instanceof Error?u.message:String(u);throw new p(zr,{cause:u})}},decode:n=>{try{return o(n)}catch(i){let u=i instanceof Error?i.message:String(i);throw new l(u,{cause:i})}}})}function $r(r){let{name:e="custom",hmac:t,randomBytes:o,constantTimeEqual:n}=r;return Object.freeze({name:e,hmac:t,randomBytes:o,constantTimeEqual:n??er})}function jr(r){return r.crypto!==void 0&&r.base32!==void 0}function Hr(r){return r.crypto!==void 0}function Kr(r){return r.base32!==void 0}0&&(module.exports={AfterTimeStepError,AfterTimeStepNegativeError,AfterTimeStepNotIntegerError,AfterTimeStepRangeExceededError,AlgorithmError,Base32Context,Base32DecodeError,Base32EncodeError,Base32Error,Base32PluginMissingError,ConfigurationError,CounterError,CounterNegativeError,CounterNotIntegerError,CounterOverflowError,CounterToleranceError,CounterToleranceNegativeError,CounterToleranceTooLargeError,CryptoContext,CryptoError,CryptoPluginMissingError,DEFAULT_PERIOD,DigitsError,EpochToleranceError,EpochToleranceNegativeError,EpochToleranceTooLargeError,HMACError,IssuerMissingError,LabelMissingError,MAX_COUNTER,MAX_PERIOD,MAX_SECRET_BYTES,MAX_WINDOW,MIN_PERIOD,MIN_SECRET_BYTES,OTPError,PeriodError,PeriodTooLargeError,PeriodTooSmallError,PluginError,RECOMMENDED_SECRET_BYTES,RandomBytesError,SecretError,SecretMissingError,SecretTooLongError,SecretTooShortError,SecretTypeError,TimeError,TimeNegativeError,TimeNotFiniteError,TokenError,TokenFormatError,TokenLengthError,bytesToString,constantTimeEqual,counterToBytes,createBase32Context,createBase32Plugin,createCryptoContext,createCryptoPlugin,createGuardrails,dynamicTruncate,generateSecret,getDigestSize,hasBase32,hasCrypto,hasGuardrailOverrides,hasPlugins,normalizeCounterTolerance,normalizeEpochTolerance,normalizeSecret,requireBase32Plugin,requireBase32String,requireCryptoPlugin,requireIssuer,requireLabel,requireSecret,stringToBytes,truncateDigits,validateByteLengthEqual,validateCounter,validateCounterTolerance,validateEpochTolerance,validatePeriod,validateSecret,validateTime,validateToken,wrapResult,wrapResultAsync});
//# sourceMappingURL=index.cjs.map