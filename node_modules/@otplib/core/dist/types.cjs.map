{"version":3,"sources":["../src/types.ts"],"sourcesContent":["/**\n * Supported hash algorithms for HMAC operations\n */\nexport type HashAlgorithm = \"sha1\" | \"sha256\" | \"sha512\";\n\n/**\n * Number of characters in the OTP code.\n *\n * Standard TOTP/HOTP uses 6-8 digits. Non-standard variants (e.g., Steam Guard)\n * may use different lengths. Runtime validation is handled by guardrails.\n */\nexport type Digits = number;\n\n/**\n * Hooks for customizing OTP token encoding and validation.\n *\n * These allow non-standard OTP variants (e.g., Steam Guard) to hook into\n * the generation and verification pipeline, replacing the default numeric\n * encoding with custom schemes without modifying core behavior.\n *\n * When not provided, the standard RFC 4226 numeric encoding is used.\n *\n * @example Steam Guard integration\n * ```typescript\n * import { generate } from '@otplib/totp';\n * import { steam } from '@otplib/community-plugin-steam';\n *\n * const code = await generate({\n *   secret,\n *   crypto,\n *   ...steam, // { digits: 5, hooks: { encodeToken, validateToken } }\n * });\n * ```\n */\nexport type OTPHooks = {\n  /**\n   * Custom token encoder. Replaces the default numeric encoding (truncateDigits).\n   *\n   * Receives the 31-bit truncated HMAC integer and the desired code length,\n   * and must return the formatted token string.\n   *\n   * @param truncatedValue - 31-bit unsigned integer from dynamic truncation\n   * @param digits - Desired token length\n   * @returns Encoded token string\n   */\n  readonly encodeToken?: (truncatedValue: number, digits: number) => string;\n\n  /**\n   * Custom token validator. Replaces the default digit-only format check.\n   *\n   * Should throw an error if the token is malformed for this encoding scheme.\n   *\n   * @param token - Token string to validate\n   * @param digits - Expected token length\n   * @throws {Error} If token format is invalid\n   */\n  readonly validateToken?: (token: string, digits: number) => void;\n\n  /**\n   * Custom HMAC digest truncation. Replaces the default RFC 4226 dynamic truncation.\n   *\n   * Receives the raw HMAC digest and must return a 31-bit unsigned integer\n   * (0â€“2,147,483,647). The integer is then passed to `encodeToken` (or the\n   * default `truncateDigits`) to produce the final token string.\n   *\n   * @param hmacResult - Raw HMAC digest as a byte array\n   * @returns 31-bit unsigned integer (0 to 0x7FFFFFFF)\n   *\n   * @example Static truncation (always use first 4 bytes)\n   * ```typescript\n   * const truncateDigest = (hmac: Uint8Array): number =>\n   *   ((hmac[0] & 0x7f) << 24) | (hmac[1] << 16) | (hmac[2] << 8) | hmac[3];\n   * ```\n   */\n  readonly truncateDigest?: (hmacResult: Uint8Array) => number;\n};\n\n/**\n * Cryptographic plugin type for abstracting HMAC and random byte generation\n * across different runtime environments (Node.js, browser, edge, etc.)\n */\nexport type CryptoPlugin = {\n  /**\n   * The name of the crypto plugin (e.g., 'node', 'web', 'js')\n   */\n  readonly name: string;\n\n  /**\n   * Compute HMAC using the specified hash algorithm\n   *\n   * @param algorithm - The hash algorithm to use\n   * @param key - The secret key as a byte array\n   * @param data - The data to authenticate as a byte array\n   * @returns HMAC digest as a byte array\n   */\n  hmac(\n    algorithm: HashAlgorithm,\n    key: Uint8Array,\n    data: Uint8Array,\n  ): Promise<Uint8Array> | Uint8Array;\n\n  /**\n   * Generate cryptographically secure random bytes\n   *\n   * @param length - Number of random bytes to generate\n   * @returns Random bytes\n   */\n  randomBytes(length: number): Uint8Array;\n\n  /**\n   * Constant-time comparison to prevent timing side-channel attacks\n   *\n   * Compares two values in a way that takes constant time regardless of\n   * whether they match or differ. This prevents timing attacks where an\n   * attacker could determine the secret by measuring comparison time.\n   *\n   * @param a - First value to compare (string or Uint8Array)\n   * @param b - Second value to compare (string or Uint8Array)\n   * @returns true if values are equal, false otherwise\n   */\n  constantTimeEqual(a: string | Uint8Array, b: string | Uint8Array): boolean;\n};\n\n/**\n * Base32 encoding/decoding options\n */\nexport type Base32EncodeOptions = {\n  /**\n   * Whether to include padding characters (=)\n   * Default: false (Google Authenticator compatible)\n   * Note: RFC 4648 specifies padding should be included\n   */\n  padding?: boolean;\n};\n\n/**\n * Base32 plugin type for abstracting Base32 encoding/decoding\n * across different implementations (native, TypeScript, etc.)\n */\nexport type Base32Plugin = {\n  /**\n   * The name of the base32 plugin (e.g., 'native', 'ts')\n   */\n  readonly name: string;\n\n  /**\n   * Encode binary data to Base32 string\n   *\n   * @param data - Uint8Array to encode\n   * @param options - Encoding options\n   * @returns Base32 encoded string\n   */\n  encode(data: Uint8Array, options?: Base32EncodeOptions): string;\n\n  /**\n   * Decode Base32 string to binary data\n   *\n   * @param str - Base32 string to decode\n   * @returns Decoded Uint8Array\n   * @throws {Error} If string contains invalid characters\n   */\n  decode(str: string): Uint8Array;\n};\n\n/**\n * Base options for secret generation\n */\nexport type SecretOptions = {\n  /**\n   * Crypto plugin for random byte generation\n   */\n  readonly crypto: CryptoPlugin;\n\n  /**\n   * Base32 plugin for encoding\n   */\n  readonly base32: Base32Plugin;\n\n  /**\n   * Number of random bytes to generate (default: 20)\n   * 20 bytes = 160 bits, which provides a good security margin\n   */\n  readonly length?: number;\n};\n\n// ============================================================================\n// Result Type for Functional Error Handling\n// ============================================================================\n\n/**\n * Success result containing a value\n */\nexport type OTPResultOk<T> = {\n  readonly ok: true;\n  readonly value: T;\n};\n\n/**\n * Failure result containing an error\n */\nexport type OTPResultError<E> = {\n  readonly ok: false;\n  readonly error: E;\n};\n\n/**\n * Result type for functional error handling\n *\n * Allows returning errors as values instead of throwing exceptions.\n * Use with `generateSafe()` and `verifySafe()` functions.\n *\n * @example\n * ```typescript\n * const result = await generateSafe({ secret, crypto, base32 });\n * if (result.ok) {\n *   console.log('Token:', result.value);\n * } else {\n *   console.log('Error:', result.error.message);\n * }\n * ```\n */\nexport type OTPResult<T, E = Error> = OTPResultOk<T> | OTPResultError<E>;\n"],"mappings":"+WAAA,IAAAA,EAAA,kBAAAC,EAAAD","names":["types_exports","__toCommonJS"]}