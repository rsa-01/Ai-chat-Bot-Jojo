import{generateSecret as h,ConfigurationError as m}from"@otplib/core";import{generate as d,generateSync as P,verify as S,verifySync as V}from"@otplib/hotp";import{generate as b,generateSync as x,verify as H,verifySync as R}from"@otplib/totp";import{generateTOTP as k,generateHOTP as v}from"@otplib/uri";import{createGuardrails as O}from"@otplib/core";import{base32 as y}from"@otplib/plugin-base32-scure";import{crypto as f}from"@otplib/plugin-crypto-noble";function u(t){return{secret:t.secret,strategy:t.strategy??"totp",crypto:t.crypto??f,base32:t.base32??y,algorithm:t.algorithm??"sha1",digits:t.digits??6,period:t.period??30,epoch:t.epoch??Math.floor(Date.now()/1e3),t0:t.t0??0,counter:t.counter,guardrails:t.guardrails??O(),hooks:t.hooks}}function T(t){return{...u(t),token:t.token,epochTolerance:t.epochTolerance??0,counterTolerance:t.counterTolerance??0,afterTimeStep:t.afterTimeStep}}function g(t,e,r){if(t==="totp")return r.totp();if(t==="hotp"){if(e===void 0)throw new m("Counter is required for HOTP strategy. Example: { strategy: 'hotp', counter: 0 }");return r.hotp(e)}throw new m(`Unknown OTP strategy: ${t}. Valid strategies are 'totp' or 'hotp'.`)}function j(t){let{crypto:e=f,base32:r=y,length:o=20}=t||{};return h({crypto:e,base32:r,length:o})}function A(t){let{strategy:e="totp",issuer:r,label:o,secret:a,algorithm:i="sha1",digits:n=6,period:s=30,counter:p}=t;return g(e,p,{totp:()=>k({issuer:r,label:o,secret:a,algorithm:i,digits:n,period:s}),hotp:c=>v({issuer:r,label:o,secret:a,algorithm:i,digits:n,counter:c})})}async function E(t){let e=u(t),{secret:r,crypto:o,base32:a,algorithm:i,digits:n,hooks:s}=e,p={secret:r,crypto:o,base32:a,algorithm:i,digits:n,hooks:s};return g(e.strategy,e.counter,{totp:()=>b({...p,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:c=>d({...p,counter:c,guardrails:e.guardrails})})}function q(t){let e=u(t),{secret:r,crypto:o,base32:a,algorithm:i,digits:n}=e,s={secret:r,crypto:o,base32:a,algorithm:i,digits:n};return g(e.strategy,e.counter,{totp:()=>x({...s,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:p=>P({...s,counter:p,guardrails:e.guardrails})})}async function M(t){let e=T(t),{secret:r,token:o,crypto:a,base32:i,algorithm:n,digits:s,hooks:p}=e,c={secret:r,token:o,crypto:a,base32:i,algorithm:n,digits:s,hooks:p};return g(e.strategy,e.counter,{totp:()=>H({...c,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,afterTimeStep:e.afterTimeStep,guardrails:e.guardrails}),hotp:l=>S({...c,counter:l,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}function $(t){let e=T(t),{secret:r,token:o,crypto:a,base32:i,algorithm:n,digits:s,hooks:p}=e,c={secret:r,token:o,crypto:a,base32:i,algorithm:n,digits:s,hooks:p};return g(e.strategy,e.counter,{totp:()=>R({...c,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,afterTimeStep:e.afterTimeStep,guardrails:e.guardrails}),hotp:l=>V({...c,counter:l,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}export{E as generate,j as generateSecret,q as generateSync,A as generateURI,M as verify,$ as verifySync};
//# sourceMappingURL=functional.js.map