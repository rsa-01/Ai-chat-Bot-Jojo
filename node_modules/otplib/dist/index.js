import{generateSecret as R,ConfigurationError as S}from"@otplib/core";import{generate as G,generateSync as x,verify as H,verifySync as v}from"@otplib/hotp";import{generate as C,generateSync as k,verify as U,verifySync as B}from"@otplib/totp";import{generateTOTP as A,generateHOTP as D}from"@otplib/uri";import{createGuardrails as V}from"@otplib/core";import{base32 as u}from"@otplib/plugin-base32-scure";import{crypto as g}from"@otplib/plugin-crypto-noble";function c(t){return{secret:t.secret,strategy:t.strategy??"totp",crypto:t.crypto??g,base32:t.base32??u,algorithm:t.algorithm??"sha1",digits:t.digits??6,period:t.period??30,epoch:t.epoch??Math.floor(Date.now()/1e3),t0:t.t0??0,counter:t.counter,guardrails:t.guardrails??V(),hooks:t.hooks}}function O(t){return{...c(t),token:t.token,epochTolerance:t.epochTolerance??0,counterTolerance:t.counterTolerance??0,afterTimeStep:t.afterTimeStep}}function l(t,e,r){if(t==="totp")return r.totp();if(t==="hotp"){if(e===void 0)throw new S("Counter is required for HOTP strategy. Example: { strategy: 'hotp', counter: 0 }");return r.hotp(e)}throw new S(`Unknown OTP strategy: ${t}. Valid strategies are 'totp' or 'hotp'.`)}function I(t){let{crypto:e=g,base32:r=u,length:a=20}=t||{};return R({crypto:e,base32:r,length:a})}function T(t){let{strategy:e="totp",issuer:r,label:a,secret:o,algorithm:i="sha1",digits:s=6,period:n=30,counter:p}=t;return l(e,p,{totp:()=>A({issuer:r,label:a,secret:o,algorithm:i,digits:s,period:n}),hotp:y=>D({issuer:r,label:a,secret:o,algorithm:i,digits:s,counter:y})})}async function m(t){let e=c(t),{secret:r,crypto:a,base32:o,algorithm:i,digits:s,hooks:n}=e,p={secret:r,crypto:a,base32:o,algorithm:i,digits:s,hooks:n};return l(e.strategy,e.counter,{totp:()=>C({...p,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:y=>G({...p,counter:y,guardrails:e.guardrails})})}function h(t){let e=c(t),{secret:r,crypto:a,base32:o,algorithm:i,digits:s}=e,n={secret:r,crypto:a,base32:o,algorithm:i,digits:s};return l(e.strategy,e.counter,{totp:()=>k({...n,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:p=>x({...n,counter:p,guardrails:e.guardrails})})}async function P(t){let e=O(t),{secret:r,token:a,crypto:o,base32:i,algorithm:s,digits:n,hooks:p}=e,y={secret:r,token:a,crypto:o,base32:i,algorithm:s,digits:n,hooks:p};return l(e.strategy,e.counter,{totp:()=>U({...y,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,afterTimeStep:e.afterTimeStep,guardrails:e.guardrails}),hotp:f=>H({...y,counter:f,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}function d(t){let e=O(t),{secret:r,token:a,crypto:o,base32:i,algorithm:s,digits:n,hooks:p}=e,y={secret:r,token:a,crypto:o,base32:i,algorithm:s,digits:n,hooks:p};return l(e.strategy,e.counter,{totp:()=>B({...y,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,afterTimeStep:e.afterTimeStep,guardrails:e.guardrails}),hotp:f=>v({...y,counter:f,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}import{createGuardrails as w,generateSecret as j}from"@otplib/core";var b=class{strategy;crypto;base32;guardrails;constructor(e={}){let{strategy:r="totp",crypto:a=g,base32:o=u,guardrails:i}=e;this.strategy=r,this.crypto=a,this.base32=o,this.guardrails=w(i)}getStrategy(){return this.strategy}generateSecret(e=20){return j({crypto:this.crypto,base32:this.base32,length:e})}async generate(e){return m({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}generateSync(e){return h({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}async verify(e){return P({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}verifySync(e){return d({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}generateURI(e){return T({...e,strategy:this.strategy})}};import{HOTP as re}from"@otplib/hotp";import{TOTP as oe}from"@otplib/totp";import{createGuardrails as se,stringToBytes as ne,wrapResult as pe,wrapResultAsync as ye}from"@otplib/core";import{NobleCryptoPlugin as ge}from"@otplib/plugin-crypto-noble";import{ScureBase32Plugin as ce}from"@otplib/plugin-base32-scure";export{re as HOTP,ge as NobleCryptoPlugin,b as OTP,ce as ScureBase32Plugin,oe as TOTP,se as createGuardrails,m as generate,I as generateSecret,h as generateSync,T as generateURI,ne as stringToBytes,P as verify,d as verifySync,pe as wrapResult,ye as wrapResultAsync};
//# sourceMappingURL=index.js.map