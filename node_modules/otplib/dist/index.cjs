"use strict";var H=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var j=Object.prototype.hasOwnProperty;var z=(t,e)=>{for(var r in e)H(t,r,{get:e[r],enumerable:!0})},W=(t,e,r,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of w(e))!j.call(t,a)&&a!==r&&H(t,a,{get:()=>e[a],enumerable:!(o=I(e,a))||o.enumerable});return t};var E=t=>W(H({},"__esModule",{value:!0}),t);var F={};z(F,{HOTP:()=>U.HOTP,NobleCryptoPlugin:()=>A.NobleCryptoPlugin,OTP:()=>R,ScureBase32Plugin:()=>D.ScureBase32Plugin,TOTP:()=>B.TOTP,createGuardrails:()=>l.createGuardrails,generate:()=>d,generateSecret:()=>k,generateSync:()=>b,generateURI:()=>P,stringToBytes:()=>l.stringToBytes,verify:()=>S,verifySync:()=>V,wrapResult:()=>l.wrapResult,wrapResultAsync:()=>l.wrapResultAsync});module.exports=E(F);var O=require("@otplib/core"),u=require("@otplib/hotp"),g=require("@otplib/totp"),h=require("@otplib/uri");var C=require("@otplib/core"),c=require("@otplib/plugin-base32-scure"),f=require("@otplib/plugin-crypto-noble");function m(t){return{secret:t.secret,strategy:t.strategy??"totp",crypto:t.crypto??f.crypto,base32:t.base32??c.base32,algorithm:t.algorithm??"sha1",digits:t.digits??6,period:t.period??30,epoch:t.epoch??Math.floor(Date.now()/1e3),t0:t.t0??0,counter:t.counter,guardrails:t.guardrails??(0,C.createGuardrails)(),hooks:t.hooks}}function v(t){return{...m(t),token:t.token,epochTolerance:t.epochTolerance??0,counterTolerance:t.counterTolerance??0,afterTimeStep:t.afterTimeStep}}function T(t,e,r){if(t==="totp")return r.totp();if(t==="hotp"){if(e===void 0)throw new O.ConfigurationError("Counter is required for HOTP strategy. Example: { strategy: 'hotp', counter: 0 }");return r.hotp(e)}throw new O.ConfigurationError(`Unknown OTP strategy: ${t}. Valid strategies are 'totp' or 'hotp'.`)}function k(t){let{crypto:e=f.crypto,base32:r=c.base32,length:o=20}=t||{};return(0,O.generateSecret)({crypto:e,base32:r,length:o})}function P(t){let{strategy:e="totp",issuer:r,label:o,secret:a,algorithm:i="sha1",digits:s=6,period:n=30,counter:p}=t;return T(e,p,{totp:()=>(0,h.generateTOTP)({issuer:r,label:o,secret:a,algorithm:i,digits:s,period:n}),hotp:y=>(0,h.generateHOTP)({issuer:r,label:o,secret:a,algorithm:i,digits:s,counter:y})})}async function d(t){let e=m(t),{secret:r,crypto:o,base32:a,algorithm:i,digits:s,hooks:n}=e,p={secret:r,crypto:o,base32:a,algorithm:i,digits:s,hooks:n};return T(e.strategy,e.counter,{totp:()=>(0,g.generate)({...p,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:y=>(0,u.generate)({...p,counter:y,guardrails:e.guardrails})})}function b(t){let e=m(t),{secret:r,crypto:o,base32:a,algorithm:i,digits:s}=e,n={secret:r,crypto:o,base32:a,algorithm:i,digits:s};return T(e.strategy,e.counter,{totp:()=>(0,g.generateSync)({...n,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:p=>(0,u.generateSync)({...n,counter:p,guardrails:e.guardrails})})}async function S(t){let e=v(t),{secret:r,token:o,crypto:a,base32:i,algorithm:s,digits:n,hooks:p}=e,y={secret:r,token:o,crypto:a,base32:i,algorithm:s,digits:n,hooks:p};return T(e.strategy,e.counter,{totp:()=>(0,g.verify)({...y,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,afterTimeStep:e.afterTimeStep,guardrails:e.guardrails}),hotp:x=>(0,u.verify)({...y,counter:x,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}function V(t){let e=v(t),{secret:r,token:o,crypto:a,base32:i,algorithm:s,digits:n,hooks:p}=e,y={secret:r,token:o,crypto:a,base32:i,algorithm:s,digits:n,hooks:p};return T(e.strategy,e.counter,{totp:()=>(0,g.verifySync)({...y,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,afterTimeStep:e.afterTimeStep,guardrails:e.guardrails}),hotp:x=>(0,u.verifySync)({...y,counter:x,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}var G=require("@otplib/core");var R=class{strategy;crypto;base32;guardrails;constructor(e={}){let{strategy:r="totp",crypto:o=f.crypto,base32:a=c.base32,guardrails:i}=e;this.strategy=r,this.crypto=o,this.base32=a,this.guardrails=(0,G.createGuardrails)(i)}getStrategy(){return this.strategy}generateSecret(e=20){return(0,G.generateSecret)({crypto:this.crypto,base32:this.base32,length:e})}async generate(e){return d({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}generateSync(e){return b({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}async verify(e){return S({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}verifySync(e){return V({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}generateURI(e){return P({...e,strategy:this.strategy})}};var U=require("@otplib/hotp"),B=require("@otplib/totp"),l=require("@otplib/core"),A=require("@otplib/plugin-crypto-noble"),D=require("@otplib/plugin-base32-scure");0&&(module.exports={HOTP,NobleCryptoPlugin,OTP,ScureBase32Plugin,TOTP,createGuardrails,generate,generateSecret,generateSync,generateURI,stringToBytes,verify,verifySync,wrapResult,wrapResultAsync});
//# sourceMappingURL=index.cjs.map