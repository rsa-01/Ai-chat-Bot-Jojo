import{createGuardrails as A,generateSecret as I}from"@otplib/core";import{createGuardrails as V}from"@otplib/core";import{base32 as y}from"@otplib/plugin-base32-scure";import{crypto as c}from"@otplib/plugin-crypto-noble";function l(r){return{secret:r.secret,strategy:r.strategy??"totp",crypto:r.crypto??c,base32:r.base32??y,algorithm:r.algorithm??"sha1",digits:r.digits??6,period:r.period??30,epoch:r.epoch??Math.floor(Date.now()/1e3),t0:r.t0??0,counter:r.counter,guardrails:r.guardrails??V(),hooks:r.hooks}}function m(r){return{...l(r),token:r.token,epochTolerance:r.epochTolerance??0,counterTolerance:r.counterTolerance??0,afterTimeStep:r.afterTimeStep}}import{generateSecret as q,ConfigurationError as T}from"@otplib/core";import{generate as R,generateSync as G,verify as H,verifySync as x}from"@otplib/hotp";import{generate as v,generateSync as k,verify as C,verifySync as D}from"@otplib/totp";import{generateTOTP as U,generateHOTP as B}from"@otplib/uri";function u(r,e,t){if(r==="totp")return t.totp();if(r==="hotp"){if(e===void 0)throw new T("Counter is required for HOTP strategy. Example: { strategy: 'hotp', counter: 0 }");return t.hotp(e)}throw new T(`Unknown OTP strategy: ${r}. Valid strategies are 'totp' or 'hotp'.`)}function h(r){let{strategy:e="totp",issuer:t,label:a,secret:i,algorithm:o="sha1",digits:s=6,period:n=30,counter:p}=r;return u(e,p,{totp:()=>U({issuer:t,label:a,secret:i,algorithm:o,digits:s,period:n}),hotp:g=>B({issuer:t,label:a,secret:i,algorithm:o,digits:s,counter:g})})}async function O(r){let e=l(r),{secret:t,crypto:a,base32:i,algorithm:o,digits:s,hooks:n}=e,p={secret:t,crypto:a,base32:i,algorithm:o,digits:s,hooks:n};return u(e.strategy,e.counter,{totp:()=>v({...p,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:g=>R({...p,counter:g,guardrails:e.guardrails})})}function d(r){let e=l(r),{secret:t,crypto:a,base32:i,algorithm:o,digits:s}=e,n={secret:t,crypto:a,base32:i,algorithm:o,digits:s};return u(e.strategy,e.counter,{totp:()=>k({...n,period:e.period,epoch:e.epoch,t0:e.t0,guardrails:e.guardrails}),hotp:p=>G({...n,counter:p,guardrails:e.guardrails})})}async function P(r){let e=m(r),{secret:t,token:a,crypto:i,base32:o,algorithm:s,digits:n,hooks:p}=e,g={secret:t,token:a,crypto:i,base32:o,algorithm:s,digits:n,hooks:p};return u(e.strategy,e.counter,{totp:()=>C({...g,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,afterTimeStep:e.afterTimeStep,guardrails:e.guardrails}),hotp:f=>H({...g,counter:f,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}function b(r){let e=m(r),{secret:t,token:a,crypto:i,base32:o,algorithm:s,digits:n,hooks:p}=e,g={secret:t,token:a,crypto:i,base32:o,algorithm:s,digits:n,hooks:p};return u(e.strategy,e.counter,{totp:()=>D({...g,period:e.period,epoch:e.epoch,t0:e.t0,epochTolerance:e.epochTolerance,afterTimeStep:e.afterTimeStep,guardrails:e.guardrails}),hotp:f=>x({...g,counter:f,counterTolerance:e.counterTolerance,guardrails:e.guardrails})})}var S=class{strategy;crypto;base32;guardrails;constructor(e={}){let{strategy:t="totp",crypto:a=c,base32:i=y,guardrails:o}=e;this.strategy=t,this.crypto=a,this.base32=i,this.guardrails=A(o)}getStrategy(){return this.strategy}generateSecret(e=20){return I({crypto:this.crypto,base32:this.base32,length:e})}async generate(e){return O({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}generateSync(e){return d({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}async verify(e){return P({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}verifySync(e){return b({...e,strategy:this.strategy,crypto:this.crypto,base32:this.base32,guardrails:e.guardrails??this.guardrails})}generateURI(e){return h({...e,strategy:this.strategy})}};export{S as OTP};
//# sourceMappingURL=class.js.map